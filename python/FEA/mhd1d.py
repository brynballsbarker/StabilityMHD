import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import root, fsolve
import scipy.linalg as la
from time import time
from tqdm import tqdm

import matplotlib.animation as animation

from solve1d import solve
from linear1d import solve as lsolve
from get_profile import profile


#y1 = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9998, 0.9998, 0.9998, 0.9998, 0.9998, 0.9997, 0.9997, 0.9996, 0.9996, 0.9996, 0.9995, 0.9994, 0.9994, 0.9993, 0.9992, 0.9991, 0.999, 0.9989, 0.9987, 0.9986, 0.9984, 0.9982, 0.998, 0.9978, 0.9975, 0.9972, 0.9968, 0.9965, 0.996, 0.9956, 0.995, 0.9944, 0.9938, 0.993, 0.9922, 0.9913, 0.9903, 0.9891, 0.9879, 0.9865, 0.985, 0.9833, 0.9815, 0.9794, 0.9772, 0.9748, 0.9721, 0.9692, 0.9661, 0.9628, 0.9592, 0.9554, 0.9513, 0.947, 0.9424, 0.9376, 0.9326, 0.9275, 0.9222, 0.9167, 0.9112, 0.9056, 0.9, 0.8944, 0.8888, 0.8833, 0.878, 0.8727, 0.8676, 0.8628, 0.8581, 0.8536, 0.8494, 0.8454, 0.8416, 0.8381, 0.8348, 0.8317, 0.8289, 0.8263, 0.8238, 0.8216, 0.8196, 0.8177, 0.816, 0.8145, 0.8131, 0.8118, 0.8106, 0.8096, 0.8086, 0.8078, 0.807, 0.8063, 0.8057, 0.8051, 0.8046, 0.8041, 0.8037, 0.8033, 0.803, 0.8027, 0.8024, 0.8021, 0.8019, 0.8017, 0.8015, 0.8014, 0.8012, 0.8011, 0.801, 0.8009, 0.8008, 0.8007, 0.8006, 0.8006, 0.8005, 0.8005, 0.8004, 0.8004, 0.8003, 0.8003, 0.8003, 0.8002, 0.8002, 0.8002, 0.8002, 0.8002, 0.8001, 0.8001, 0.8001, 0.8001, 0.8001, 0.8001, 0.8001, 0.8001, 0.8001, 0.8001, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8]

#y2 = [0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.661, 0.6611, 0.6611, 0.6611, 0.6611, 0.6611, 0.6611, 0.6611, 0.6611, 0.6611, 0.6612, 0.6612, 0.6612, 0.6612, 0.6613, 0.6613, 0.6614, 0.6614, 0.6615, 0.6615, 0.6616, 0.6616, 0.6617, 0.6618, 0.6619, 0.662, 0.6622, 0.6623, 0.6625, 0.6626, 0.6628, 0.6631, 0.6633, 0.6636, 0.6639, 0.6643, 0.6646, 0.6651, 0.6656, 0.6661, 0.6667, 0.6673, 0.6681, 0.6689, 0.6698, 0.6708, 0.6718, 0.673, 0.6743, 0.6757, 0.6772, 0.6789, 0.6807, 0.6826, 0.6847, 0.6869, 0.6892, 0.6917, 0.6942, 0.6969, 0.6997, 0.7026, 0.7055, 0.7086, 0.7116, 0.7147, 0.7177, 0.7207, 0.7237, 0.7267, 0.7295, 0.7323, 0.735, 0.7375, 0.7399, 0.7423, 0.7444, 0.7465, 0.7484, 0.7502, 0.7519, 0.7534, 0.7548, 0.7561, 0.7573, 0.7584, 0.7594, 0.7604, 0.7612, 0.762, 0.7627, 0.7633, 0.7639, 0.7644, 0.7648, 0.7653, 0.7656, 0.766, 0.7663, 0.7666, 0.7668, 0.767, 0.7672, 0.7674, 0.7676, 0.7677, 0.7679, 0.768, 0.7681, 0.7682, 0.7683, 0.7684, 0.7684, 0.7685, 0.7685, 0.7686, 0.7686, 0.7687, 0.7687, 0.7687, 0.7688, 0.7688, 0.7688, 0.7688, 0.7689, 0.7689, 0.7689, 0.7689, 0.7689, 0.7689, 0.7689, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769, 0.769]

# python mhd1d.py nx=10 nt=nx**2/2 h1=1.62 uplus=.8
print(sys.argv[0],len(sys.argv))
if len(sys.argv) == 1:
    nx = 10
    nt = 50

elif len(sys.argv) == 2:
    nx = int(sys.argv[1])
    nt = int(nx**2/2)

else:
    nx = int(sys.argv[1])
    nt = int(sys.argv[2])

# specify h1 and u_plus values
if len(sys.argv) > 3:
    h1, uplus = float(sys.argv[3]), float(sys.argv[4])
else:
    h1, uplus = 1.62, .8

# get the profile
y1,y2 = profile(h1=h1,vp=uplus,n=nx)

# define parameters
Gamma = .666
mu = .1
eta = -2/3*mu
cnu = 1
kap = .1
nu = .1
R = Gamma*cnu
alpha = 1

# compute U using profile
u = y1
rho = [1/_ for _ in u]
T = [_/cnu for _ in y2]
h1 = [2 for _ in y2]

# 

# function for initial condition
def initial(x):
    assert len(x) == len(y1)

    # return initial profile solution
    return np.array([rho,u,h1,T]).flatten()

#
def f0(u):
    res = np.copy(u)
    res[0] = u[0]
    res[1] = u[0]*u[1]
    res[2] = u[2]
    res[3] = u[2]**2/2+u[0]*(cnu*u[3]+u[1]**2/2)
    return res

def Df0(u):
    res = np.zeros((len(u),len(u)))
    res[0,0] = 1
    res[1,:2] = np.array([u[1],u[0]])
    res[2,2] = 1
    res[3,:] = np.array([cnu*u[3]+u[1]**2/2,u[0]*u[1],
                         u[2],cnu*u[0]])
    return res

def f1(u):
    res = np.copy(u)
    res[0] = u[0]*u[1]
    res[1] = R*u[0]*u[3]-u[2]**2/2+u[0]*u[1]**2
    res[2] = alpha*u[2]
    res[3] = (R+cnu)*u[3]+u[1]**2/2
    return res


def b(u):
    B = np.array([[0,0,0,0],
                 [0,nu+2*mu,0,0],
                 [0,0,nu,0],
                 [0,u[1]*(nu+2*mu),0,kap]])
    return B

# get known values at boundaries
left = [rho[0],u[0],h1[0],T[0]]
right = [rho[-1],u[-1],h1[-1],T[-1]]

# specify boundary conditions
bnds = np.ones((4,4))
bnds[:,1] = left
bnds[:,3] = right
bnds[2,0] = 0      # set rho free
#bnds[2,2] = 0      # set h1 free

# solve
sol = solve(initial,f0,f1,b,nt,nx,bnds,Df0)

# extract solution and reshape
U = sol.U.reshape((sol.nt+1,sol.numeq,sol.nx+1))

# helpful plotting lists
colors = ['C0','C1','C2','C3']
labels = [r'$\rho$','u','h','T']

# Static plot of solution
fig = plt.figure()

x = np.linspace(0,1,sol.nx+1)
for i in range(0,sol.nt+1):
    for j in range(4):
        plt.plot(x,U[i,j],color=colors[j])

plt.legend(labels)
# plt.ylim(.7,1.1)
plt.show()
